#' Calculate and plot coverage across hairpins
#'
#' @param fce fce object generated by create_fce
#' @param cells_to_plot vector of cells ids to include in coverage calculation
#' @param return_df return coverage values as a `data.frame`
#' @param ... additional arguments to pass to [`plot_hairpin_coverage()`]
#'
#' @export
plot_hairpin <- function(fce,
                         cells_to_plot = NULL,
                         return_df = FALSE,
                         ...) {
  if (is.null(cells_to_plot)) {
    cells_to_plot <- colnames(counts(fce[["fsce"]]))
  }

  hcut_metadata <- colData(fce[["fsce"]])[cells_to_plot, , drop = FALSE]
  counts <- counts(fce[["fsce"]])

  per_sample_cell_ids <- split(rownames(hcut_metadata), hcut_metadata$sample_id)

  ## compute per sample per adduct position counts
  plt_dat <- purrr::map_dfr(per_sample_cell_ids,
    function(cell_ids) {
      hairpin_info <- as.data.frame(rowData(fce[["fsce"]]))
      hairpin_info$count <- rowSums(counts[, cell_ids, drop = FALSE])
      hairpin_info
    },
    .id = "sample"
  )

  ## fix types
  plt_dat$sample <- as.character(plt_dat$sample)
  plt_dat$position <- as.numeric(plt_dat$position)

  if (return_df) {
    return(plt_dat)
  }

  plot_hairpin_coverage(plt_dat, "position", "count", ...)
}

#' Plot coverage across hairpins
#'
#' @param df dataframe with coverage data
#' @param x column to use for x-axis
#' @param y column to use for y-axis
#' @param col column to use for coloring lines (defaults to "Sample")
#' @param points show points in addition to lines (defaults to FALSE)
#' @param facet_by_hairpin plot each hairpin individually (defaults to TRUE)
#' @param pt_alpha passed to pt.alpha argument for [`ggplot2::geom_line()`] (defaults to 0.7)
#' @param pt_size passed to pt.size argument for [`ggplot2::geom_line()`] (defaults to 0.8)
#' @param xlimits two element numeric vector to supply to [`ggplot2::xlim()`] (defaults to NULL)
#'
#' @export
plot_hairpin_coverage <- function(df, x, y, col = "sample", points = FALSE, facet_by_hairpin = TRUE, xlimits = NULL) {

  x <- enquo(x)
  y <- enquo(y)
  col <- enquo(col)

  p <- ggplot(df, aes(x = !! x, y = !! y)) +
    geom_line(aes(color = !! col), alpha = 0.7, size = 0.8) +
    cowplot::theme_cowplot() +
    scale_color_brewer(palette = "Set1") +
    labs(
      x = "Position",
      y = "Counts"
    )

  if (all(c("adduct_position1", "adduct_position2") %in% colnames(df))) {
    p <- p +
      geom_vline(
        xintercept = df$adduct_position1[1],
        linetype = "dotted",
        color = "black",
        size = 1
      ) +
      geom_vline(
        xintercept = df$adduct_position2[1],
        linetype = "dotted",
        color = "black",
        size = 1
      )
  }

  if (!is.null(xlimits)) {
    p + xlim(xlimits)
  }

  if (point) {
    p <- p + geom_point(aes(color = !! col))
  }

  if (facet_by_hairpin) {
    p <- p + facet_wrap(~hairpin)
  }
  p
}

#' Plot cells in a reduced dimensionality space
#'
#' Plot cells in two dimensions. Cells can be colored using `features`, which
#' specifies gene names or columns in `colData`.
#'
#' @param fce fce object of class MultiAssayExperiment
#' @param features features to plot
#' @param ... additional arguments for `plot_feature()`
#'
#' @export
plot_cells <- function(fce, features, ...) {
  plts <- list()

  for (i in seq_along(features)) {
    plts[[i]] <- plot_feature(fce, feature = features[i], ...)
  }

  cowplot::plot_grid(plotlist = plts)
}

#' Plot cells in reduced dimensionality 2D space
#'
#' @description Cells can be colored by gene or feature in meta.data dataframe
#'
#' @param fce fce object of class MultiAssayExperiment
#' @param feature single feature to plot, either gene name or column in colData
#' @param expt Data type to use for plot, one of either sce (rna data, the
#'   default) or fsce (functional data). Defaults to "sce"
#' @param method dimensionality reduction for plotting. defaults to UMAP
#' @param plot_dat supplemental data.frame containing feature to plot. Must have
#'   a column named `cell` that contains matching colnames in colData
#' @param pt_size size of points produced by geom_point
#' @param pt_alpha alpha value for points plotted by geom_point
#' @param label_text if TRUE display feature labels on plot
#' @param label_size size of label text
#' @param label_color color of label text
#' @param .cols vector of colors to use for plot.
#' @param cell_filter character vector of cell names to include in plot
#' @param palette_type color palette type to use (either viridis, brewer, or
#'   cloupe) defaults to using cellranger loupe-like colors
#' @param col_pal palette name to use if palette_type is brewer
#' @param max_y maximum feature value to set scale to. Defaults to max of the
#'   feature
#' @param plot_title string to supply for title for the plot, otherwise title is
#'   the feature
#' @param dims_to_plot number of dimensions
#'
#' @export
plot_feature <- function(fce,
                         feature = NULL,
                         expt = "sce",
                         method = "UMAP",
                         plot_dat = NULL,
                         pt_size = 0.01,
                         pt_alpha = 1,
                         label_text = FALSE,
                         label_size = 6,
                         label_color = "grey",
                         .cols = NULL,
                         cell_filter = NULL,
                         palette_type = "cloupe",
                         col_pal = "Reds",
                         max_y = NULL,
                         plot_title = NULL,
                         dims_to_plot = c(1, 2)) {

  # check inputs
  if (!expt %in% names(assays(fce))) {
    stop("expt not found in fce object")
  }

  if (!method %in% names(reducedDims(fce[[expt]]))) {
    stop(paste0("embedding method ", method, " not found in fce object"))
  }

  embed_dat <- reducedDim(fce[[expt]], method)
  embed_dat <- embed_dat[, dims_to_plot]

  if (is.null(colnames(embed_dat))) {
    colnames(embed_dat) <- paste0(method, dims_to_plot)
  }

  xcol <- colnames(embed_dat)[1]
  ycol <- colnames(embed_dat)[2]

  embed_dat <- as.data.frame(embed_dat) %>%
    tibble::rownames_to_column("cell")

  cell_ids <- embed_dat$cell

  ## check if feature is in colData or in normalized counts
  sce_cols <- colnames(colData(fce[["sce"]]))
  fsce_cols <- colnames(colData(fce[["fsce"]]))

  meta_data_col <- TRUE

  if (feature %in% sce_cols && feature %in% fsce_cols) {
    # get feature from supplied expt
    mdata <- as.data.frame(colData(fce[[expt]])[cell_ids, , drop = F]) %>%
      tibble::rownames_to_column("cell")
  } else if (feature %in% sce_cols) {
    # get feature from sce
    mdata <- as.data.frame(colData(fce[["sce"]])[cell_ids, , drop = F]) %>%
      tibble::rownames_to_column("cell")
  } else if (feature %in% fsce_cols) {
    # get feature from fsce
    mdata <- as.data.frame(colData(fce[["fsce"]])[cell_ids, , drop = F]) %>%
      tibble::rownames_to_column("cell")
  } else {
    meta_data_col <- FALSE
  }

  if (meta_data_col) {
    embed_dat <- left_join(mdata, embed_dat, by = "cell")
  }

  if (!is.null(cell_filter)) {
    embed_dat <- dplyr::filter(
      embed_dat,
      cell %in% cell_filter
    )
  }

  ## get expression data
  if (!meta_data_col) {
    feature_dat <- fce[feature, , ]

    if (length(feature_dat) == 0) {
      stop("feature not found in object")
    }

    if (length(feature_dat) > 1) {
      # get feature from supplied expt
      feature_dat <- assay(feature_dat[[expt]], "logcounts")[, cell_ids, drop = F] %>%
        as.matrix() %>% # coerces sparseMatrix
        t() %>%
        as.data.frame() %>%
        tibble::rownames_to_column("cell")
    } else {
      feature_dat <- assay(feature_dat[[1]], "logcounts")[, cell_ids, drop = F] %>%
        as.matrix() %>% # coerces sparseMatrix
        t() %>%
        as.data.frame() %>%
        tibble::rownames_to_column("cell")
    }

    embed_dat <- left_join(embed_dat, feature_dat, by = "cell")
  }

  if (!is.null(plot_dat)) {
    embed_dat <- left_join(embed_dat, plot_dat, by = "cell")
  }

  color_aes_str <- feature

  color_aes_str_q <- quo(color_aes_str)
  embed_dat <- embed_dat %>% dplyr::arrange_at(.vars = color_aes_str)

  xcol <- enquo(xcol)
  ycol <- enquo(ycol)

  p <- ggplot(embed_dat, aes(x = !! xcol, y = !! ycol)) +
    geom_point(aes_string(color = color_aes_str),
      size = pt_size,
      alpha = pt_alpha
    )

  ## discrete or continuous data?
  if (typeof(embed_dat[[feature]]) %in% c(
    "character",
    "logical"
  ) | is.factor(embed_dat[[feature]])) {
    discrete <- TRUE
  } else {
    discrete <- FALSE
  }

  ## increase legend size
  if (discrete) {
    p <- p + guides(colour = guide_legend(override.aes = list(size = 4))) +
      theme(legend.title = element_blank())
  }

  if (label_text) {
    if (discrete) {
      tsne_mean_dat <- embed_dat %>%
        group_by_at(vars(one_of(feature))) %>%
        summarize(
          med_dim_1 = median(!!rlang::parse_quosure(xcol)),
          med_dim_2 = median(!!rlang::parse_quosure(ycol))
        )

      p <- p +
        geom_text(
          data = tsne_mean_dat,
          aes_string(
            x = "med_dim_1",
            y = "med_dim_2",
            label = feature
          ),
          size = label_size,
          color = label_color
        )
    } else {
      warning("label_text not compatible with continuous features")
    }
  }

  ## handle legend limit
  if (is.null(max_y) & !discrete) {
    max_y <- c(0, max(embed_dat[[color_aes_str]]))
  } else if (discrete & is.null(max_y)) {
    max_y <- c(NA, NA)
  }

  # loupe-like colors
  cols <- rev(RColorBrewer::brewer.pal(11, "RdGy")[c(1:5, 7)])

  # handle legend name
  if (is.null(plot_title)) plot_title <- color_aes_str

  ## handle zero expression
  if (!all(is.na(max_y)) && all(max_y == c(0, 0))) {
    p <- p + scale_color_gradient(low = cols[1], high = cols[1])
    return(p)
  }

  ## handle colors
  if (is.null(.cols) && !discrete) {
    if (palette_type == "viridis") {
      p <- p + scale_color_viridis_c(
        discrete = F,
        direction = -1,
        option = col_pal,
        limits = max_y
      )
    } else if (palette_type == "brewer") {
      p <- p + scale_color_distiller(
        limits = max_y,
        palette = col_pal,
        direction = 1
      )
    } else if (palette_type == "cloupe") {
      p <- p + scale_color_gradientn(
        limits = max_y,
        colors = cols
      )
    }
  } else if (!is.null(.cols) && !discrete) {
    p <- p + scale_color_gradientn(
      limits = max_y,
      colors = .cols
    )
  } else {
    if (!is.null(.cols)) {
      # use colors provided
      p <- p + scale_color_manual(
        values = .cols
      )
    } else {
      p <- p + scale_color_manual(
        values = discrete_palette_default
      )
    }
  }
  p <- p + labs(title = plot_title)
  p <- p + cowplot::theme_cowplot()
  p <- p + theme(legend.title = element_blank())
  p
}

#' Plot activities per cluster
#'
#' @param data data to plot
#' @param activity activity variable
#' @param group grouping variable
#'
#' @export
plot_activity <- function(data, activity, group = NULL) {

  activity <- enquo(activity)
  group <- enquo(group)

  ggplot(data, aes(x = !! activity, y = !! cluster, color = !! group)) +
    ggbeeswarm::geom_quasirandom(size = 0.5, groupOnX = FALSE) +
    scale_color_OkabeIto() +
    cowplot::theme_cowplot() +
    labs(
      x = "Activity",
      y = "Cluster",
      title = glue::glue("Activity: {activity}", activity = activity)
    )
}

#' Color palette
#' @noRd
discrete_palette_default <- c(
  RColorBrewer::brewer.pal(12, "Paired"),
  RColorBrewer::brewer.pal(9, "Set1"),
  RColorBrewer::brewer.pal(8, "Set2"),
  RColorBrewer::brewer.pal(8, "Dark2")
)

# colorblindr functions -------------------------------------------------


#' Color palette proposed by Okabe and Ito
#'
#' These functions are copied from [colorblindr](https://github.com/clauswilke/colorblindr).
#'
#' Two color palettes taken from the article "Color Universal Design" by Okabe and Ito, http://jfly.iam.u-tokyo.ac.jp/color/.
#' The variant `palette_OkabeIto` contains a gray color, while `palette_OkabeIto_black` contains black instead.
#' @export
palette_OkabeIto <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#999999")

#' @rdname palette_OkabeIto
#' @export
palette_OkabeIto_black <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000")

#' @rdname scale_OkabeIto
#' @export
#' @usage NULL
scale_colour_OkabeIto <- function(aesthetics = "colour", ...) {
  scale_OkabeIto(aesthetics, ...)
}

#' @rdname scale_OkabeIto
#' @export
#' @usage NULL
scale_color_OkabeIto <- scale_colour_OkabeIto

#' @rdname scale_OkabeIto
#' @export
#' @usage NULL
scale_fill_OkabeIto <- function(aesthetics = "fill", ...) {
  scale_OkabeIto(aesthetics, ...)
}

#' Okabe-Ito color scale
#'
#' This is a color-blind friendly, qualitative scale with eight different
#' colors. See [palette_OkabeIto] for details.
#'
#' This code is modified from colorblindr to remove the `darken` param, which
#' is only available in unreleased colorspace 0.4.1.
#'
#' @param use_black If `TRUE`, scale includes black, otherwise includes gray.
#' @param order Numeric vector listing the order in which the colors should be used. Default is 1:8.
#' @param alpha Alpha transparency level of the color. Default is no transparency.
#' @param ... common discrete scale parameters: `name`, `breaks`, `labels`, `na.value`, `limits`, `guide`, and `aesthetics`.
#'  See [discrete_scale] for more details.
#'
#' @examples
#' library(ggplot2)
#' ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species)) +
#'   geom_point() + scale_color_OkabeIto()
#' ggplot(iris, aes(Sepal.Length, fill = Species)) +
#'   geom_density(alpha = 0.7) + scale_fill_OkabeIto(order = c(1, 3, 5))
#'
#' @export
scale_OkabeIto <- function(aesthetics, use_black = FALSE, order = 1:8, alpha = NA, ...) {
  if (use_black) {
    values <- palette_OkabeIto_black[order]
  } else {
    values <- palette_OkabeIto[order]
  }

  n <- length(values)
  alpha <- rep_len(alpha, n)

  ai <- !is.na(alpha)
  if (sum(ai) > 0) { # at least one color needs alpha
    values[ai] <- scales::alpha(values[ai], alpha[ai])
  }

  pal <- function(n) {
    if (n > length(values)) {
      warning("Insufficient values in manual scale. ", n, " needed but only ",
              length(values), " provided.", call. = FALSE)
    }
    values
  }
  ggplot2::discrete_scale(aesthetics, "manual", pal, ...)
}
